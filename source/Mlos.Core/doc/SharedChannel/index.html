<!DOCTYPE html>
<html lang="en" dir=>

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="MLOS Shared Channel This document describes the implementation details of the mechanism (a shared memory communication channel) used for a target system to communicate with an external agent for tuning it.
For additional context, please see the MlosArchitecture.md documentation.
See source/Mlos.Core to browse the code.
Contents  MLOS Shared Channel  Contents Shared Channel  Principles Circular buffer algorithm  Writer Reader Writer continued Reader continue Cyclic buffer handling   Scaling out readers   Shared channel implementation  Diagram Policies Notes      Shared Channel A shared channel is a one-directional communication channel based on a single shared memory block (i.">
<meta name="theme-color" content="#FFFFFF"><meta property="og:title" content="" />
<meta property="og:description" content="MLOS Shared Channel This document describes the implementation details of the mechanism (a shared memory communication channel) used for a target system to communicate with an external agent for tuning it.
For additional context, please see the MlosArchitecture.md documentation.
See source/Mlos.Core to browse the code.
Contents  MLOS Shared Channel  Contents Shared Channel  Principles Circular buffer algorithm  Writer Reader Writer continued Reader continue Cyclic buffer handling   Scaling out readers   Shared channel implementation  Diagram Policies Notes      Shared Channel A shared channel is a one-directional communication channel based on a single shared memory block (i." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://microsoft.github.io/MLOS/source/Mlos.Core/doc/SharedChannel/" />

<title>Shared Channel | MLOS</title>
<link rel="manifest" href="/MLOS/manifest.json">
<link rel="icon" href="/MLOS/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/MLOS/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css" integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY=">
<script defer src="/MLOS/en.search.min.4c1d22a3183df6a4b6108d83685274001ccb073a450c5a95627992b0d078883c.js" integrity="sha256-TB0ioxg99qS2EI2DaFJ0ABzLBzpFDFqVYnmSsNB4iDw="></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body dir=>
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/MLOS"><span>MLOS</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>











  <ul>
<li>
<p><a href="/MLOS/documentation/">Documentation</a></p>
<ul>
<li><a href="/MLOS/documentation/01-Prerequisites/">Prerequisites</a></li>
<li><a href="/MLOS/documentation/02-Build/">Build</a></li>
<li><a href="/MLOS/documentation/04-Test/">Test</a></li>
<li><a href="/MLOS/documentation/CodingStandard/">Coding Standard</a></li>
<li><a href="/MLOS/documentation/MlosArchitecture/">Architecture</a></li>
<li><a href="/MLOS/documentation/RepoOrganization/">Repo Organization</a></li>
</ul>
</li>
<li>
<p><a href="/MLOS/notebooks/">Notebooks</a></p>
<ul>
<li><a href="/MLOS/notebooks/BayesianOptimization/">Bayesian Optimization</a></li>
<li><a href="/MLOS/notebooks/SmartCacheOptimization/">Smart Cache Optimization</a></li>
<li><a href="/MLOS/notebooks/SmartCacheCPP/">Smart Cache Optimization in C++</a></li>
<li><a href="/MLOS/notebooks/LevelDbTuning/">LevelDB External Tuning Example</a></li>
</ul>
</li>
<li>
<p><a href="/MLOS/source/Examples/">E2E Examples</a></p>
<ul>
<li><a href="/MLOS/source/Examples/SmartCache/">Smart Cache</a></li>
</ul>
</li>
<li>
<p>API Documentation</p>
<ul>
<li><a href="/MLOS/python_api/">Python</a></li>
</ul>
</li>
<li>
<p>Component Documentation</p>
<ul>
<li><a href="/MLOS/source/Mlos.SettingsSystem.CodeGen/">Mlos Settings System Code Generation System</a></li>
<li><a href="/MLOS/source/Mlos.Core/doc/">Mlos.Core Shared Memory Communication Channel</a></li>
<li><a href="/MLOS/source/Mlos.Agent.Server/">Mlos.Agent.Server</a></li>
</ul>
</li>
<li>
<p><a href="/MLOS/external/">External Integration</a></p>
</li>
<li>
<p><a href="/MLOS/CODE_OF_CONDUCT/">Code of Conduct</a></p>
</li>
<li>
<p><a href="/MLOS/CONTRIBUTING/">Contributing</a></p>
</li>
<li>
<p><a href="https://github.com/Microsoft/MLOS">MLOS Github Repository</a></p>
</li>
</ul>










</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/MLOS/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Shared Channel</strong>

  <label for="toc-control">
    
    <img src="/MLOS/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  <nav id="TableOfContents">
  <ul>
    <li><a href="#contents">Contents</a></li>
    <li><a href="#shared-channel">Shared Channel</a>
      <ul>
        <li><a href="#principles">Principles</a></li>
        <li><a href="#circular-buffer-algorithm">Circular buffer algorithm</a></li>
        <li><a href="#scaling-out-readers">Scaling out readers</a></li>
      </ul>
    </li>
    <li><a href="#shared-channel-implementation">Shared channel implementation</a>
      <ul>
        <li><a href="#diagram">Diagram</a></li>
        <li><a href="#policies">Policies</a></li>
        <li><a href="#notes">Notes</a></li>
      </ul>
    </li>
  </ul>
</nav>


  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="mlos-shared-channel">MLOS Shared Channel</h1>
<p>This document describes the implementation details of the mechanism (a shared memory communication channel) used for a target system to communicate with an external agent for tuning it.</p>
<p>For additional context, please see the <a href="/MLOS/source/Mlos.Core/doc/../../../documentation/MlosArchitecture/">MlosArchitecture.md</a> documentation.</p>
<p>See <a href="https://github.com/microsoft/MLOS/tree/main/source/Mlos.Core/doc/../">source/Mlos.Core</a> to browse the code.</p>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#mlos-shared-channel">MLOS Shared Channel</a>
<ul>
<li><a href="#contents">Contents</a></li>
<li><a href="#shared-channel">Shared Channel</a>
<ul>
<li><a href="#principles">Principles</a></li>
<li><a href="#circular-buffer-algorithm">Circular buffer algorithm</a>
<ul>
<li><a href="#writer">Writer</a></li>
<li><a href="#reader">Reader</a></li>
<li><a href="#writer-continued">Writer continued</a></li>
<li><a href="#reader-continue">Reader continue</a></li>
<li><a href="#cyclic-buffer-handling">Cyclic buffer handling</a></li>
</ul>
</li>
<li><a href="#scaling-out-readers">Scaling out readers</a></li>
</ul>
</li>
<li><a href="#shared-channel-implementation">Shared channel implementation</a>
<ul>
<li><a href="#diagram">Diagram</a></li>
<li><a href="#policies">Policies</a></li>
<li><a href="#notes">Notes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="shared-channel">Shared Channel</h2>
<p>A <em>shared channel</em> is a one-directional communication channel based on a single shared memory block (i.e. between processes).
It supports multiple concurrent writers and readers.</p>
<p>Its purpose is to allow exposing information from a target system to an external agent (e.g. <code>Mlos.Agent</code>) and providing feedback from that external agent to control the target system&rsquo;s tunables.</p>
<p>Typically there are several shared channels in each system:</p>
<ul>
<li>A <em>control</em> channel for registering settings to setup up additional channels.</li>
<li>One or more (e.g. for each tunable component) <em>telemetry</em> and <em>feedback</em> channel pairs.</li>
</ul>
<p>Messages are exchanged on a shared channel as <em>Frames</em>.
Frames can be variable length (e.g. if they include variable length data like strings) or fixed length (e.g. just numerical data).
The format of each frame is code generated by <code>Mlos.SettingsSystem.CodeGen</code> from annotated C# data structures specified in a <code>SettingsRegistry</code> provided by the developer.
See <a href="/MLOS/source/Mlos.Core/doc/../../Mlos.SettingsSystem.CodeGen/">Mlos Settings System Code Generation</a> more details on the code generation and settings system.</p>
<h3 id="principles">Principles</h3>
<p><img src="/MLOS/source/Mlos.Core/doc/images/CircularBuffer.svg" alt="Circular buffer diagram" /></p>
<p>The shared channel is comprised of four contiguous memory regions (though at times some of them could have zero size):</p>
<ol>
<li>
<p><em>FreeRegion</em> - a writer can acquire the region by (atomically) saving the original <em>WritePosition</em>, and advancing <em>WritePosition</em> by the frame size. The writer can then write the frame at the <em>WriteOffset</em> = (original <em>WritePosition</em>) % Buffer.Size.</p>
</li>
<li>
<p><em>DirtyRegion</em> - contains already processed (read) frames that are ready to be reclaimed (as indicated in the frame&rsquo;s header). Writers are responsible for reclaiming frames and advancing the <em>FreePosition</em>.</p>
</li>
<li>
<p><em>ActiveReadsRegion</em> - a memory region between the start of the oldest unprocessed frame start and the <em>ReadPosition</em> (logically) or <em>ReadOffset</em> (physically). Readers are actively processing messages in this region.</p>
</li>
<li>
<p><em>ActiveWritesRegion</em> - a memory region between the <em>ReadPosition</em> and <em>WritePosition</em> (logically) or equivalently between <em>ReadOffset</em> and <em>WriteOffset</em> (physically). This region contains both:</p>
<ul>
<li>Frames that have already been written but have not been processed yet, and</li>
<li>Frames that are being written by the writers.</li>
</ul>
<p>These two types of frames are differentiated by information contained in their headers (described below).</p>
</li>
</ol>
<p>At the <strong>logical level</strong> the boundaries between the regions are controlled by three position variables that are atomically updated:</p>
<ol>
<li><em>WritePosition</em></li>
<li><em>ReadPostion</em></li>
<li><em>FreePosition</em></li>
</ol>
<p>They are all 32-bit unsigned integers that are monotonically increasing except for integer overflows. Note that integer overflows are part of the design and do not affect correctness.</p>
<p>At the <strong>physical level</strong> the boundaries between the regions are controlled by corresponding offsets into the circular buffer:</p>
<ol>
<li><em>WriteOffset</em> = <em>WritePosition</em> % Buffer.Size</li>
<li><em>ReadOffset</em> = <em>ReadPosition</em> % Buffer.Size</li>
<li><em>FreeOffset</em> = <em>FreePosition</em> % Buffer.Size</li>
</ol>
<ul>
<li>
<p>Advancing positions is implemented with atomic CPU operations (e.g. <code>std::atomic::compare_exchange</code> or <code>Interlocked.CompareExchange</code>).</p>
</li>
<li>
<p>Reader and writer threads must use these to first <em>acquire</em> a region before touching the memory inside it.  There are two exceptions to this rule:</p>
<ol>
<li>when thread reads from memory in unknown state</li>
<li>cleanup does not require <em>acquire</em>, it just cleans up (atomically) as far as it&rsquo;s safe to do so</li>
</ol>
</li>
<li>
<p>The following invariant ensures that the <em>ActiveWritesRegion</em> will never overlap the <em>ActiveReadsRegion</em> \</p>
<p><em>FreePosition</em> &lt;= <em>ReadPosition</em> &lt;= <em>WritePosition</em> &lt; <em>FreePosition</em> + <em>Buffer.Size</em></p>
</li>
<li>
<p><em>Buffer.Size</em> must be a power of two (2<!-- raw HTML omitted --><!-- raw HTML omitted -->N<!-- raw HTML omitted --><!-- raw HTML omitted -->)</p>
</li>
</ul>
<h3 id="circular-buffer-algorithm">Circular buffer algorithm</h3>
<h4 id="writer">Writer</h4>
<p>Writer threads expand an <em>ActiveWriteRegion</em> by atomically exchanging <em>WritePosition</em> by a frame length.
If it succeeds, it means the writer has acquired the memory region and can write the frame.
The <em>ActiveWriteRegion</em> will never overlap with <em>ActiveReadsRegion</em>. The writer ensures there is a minimum gap of the size of <em>FrameHeader</em> between <em>FreeOffset</em> and <em>WriteOffset</em>.
The writer stores the frame payload and atomically updates the frame length.</p>
<h4 id="reader">Reader</h4>
<p>By default reader threads spin [1] on the <em>ReadOffset</em> which always points to the length of the next written frame.
When the value becomes available (<em>Frame.Length</em> &gt; 0), it tries to acquire the region by atomically exchanging <em>ReadPostion</em>.
If the compare and exchange fails, it means another reader thread is already processing the frame.
When it succeeds, the reader should call the proper dispatcher routine to process the contents of the frame.
After processing the frame, the reader clears the frame payload and atomically updates the <em>Frame.Length</em> to be negative [2], indicating that it is available to be written again.</p>
<blockquote>
<p>[1] Alternative <a href="#policies">policies</a> can be specified to control sleeping vs spinning behavior.</p>
<p>[2] It is possible that the reader crashes between these steps.  We use reference counting to support detecting these situations.</p>
</blockquote>
<h4 id="writer-continued">Writer continued</h4>
<p>Now, the memory occupied by the frame the reader finished with is clear, except for the negative <em>Frame.Length</em>.
Writer threads use negative frame lengths as a hint to advance <em>FreePosition</em> until <em>DirtyRegion</em> has a minimal size (according to the invariant above).</p>
<h4 id="reader-continue">Reader continue</h4>
<p>When the reader waits on the <em>ReadOffset</em>, it reads from the memory region that has not been acquired.
This is the <em>FreeRegion</em>, and the memory has been cleared by the previous reader - except for the negative <em>Frame.Length</em>.
The <em>Offset</em> of the frame is always aligned to <code>sizeof(uint32_t)</code>, so if the current <em>ReadOffset</em> is the same as the offset of the old processed frame, the reader will read a negative value.
So, the reader will spin until it reads positive frame length.</p>
<h4 id="cyclic-buffer-handling">Cyclic buffer handling</h4>
<p>If a writer is unable to write a full frame (i.e. the end of the frame is greater than buffer margin), it will write an empty frame (no payload) just to advance <em>Position</em> to the beginning of the buffer.</p>
<p>Readers can identify these empty frames using their <code>CodeGenTypeIndex</code> header, and pass over them.</p>
<h3 id="scaling-out-readers">Scaling out readers</h3>
<p><img src="/MLOS/source/Mlos.Core/doc/images/SharedChannelFrame.svg" alt="Shared channel frame diagram" /></p>
<p>To scale out the number of reader threads, we introduced a control bit which defines if the frame has been fully written.
The control bit (<code>Done</code> in the diagram above) is the lowest bit in the frame length field.</p>
<p>With the modified algorithm, the writer stores the length of the frame with the <code>Done</code> bit set to 0.
This allows one reader to acquire the current frame region while other readers threads can advance and wait for the next frame.</p>
<h2 id="shared-channel-implementation">Shared channel implementation</h2>
<h3 id="diagram">Diagram</h3>
<p><img src="/MLOS/source/Mlos.Core/doc/images/SharedChannelClasses.svg" alt="Shared channel classes diagram" /></p>
<h3 id="policies">Policies</h3>
<p>The implementation allows the use of different policies using the same shared memory buffer instance.</p>
<p>Policies are responsible for:</p>
<ul>
<li>error handling</li>
<li>cross process notification</li>
<li>handling full buffer</li>
<li>spinning implementation</li>
</ul>
<p>The shared channel requires two policies.</p>
<ol>
<li>
<p><code>TSpinPolicy</code> is responsible for the spin/wait algorithm when a frame is not available.</p>
</li>
<li>
<p><code>TChannelPolicy</code> implements error handling code and cross-process notification.</p>
</li>
</ol>
<p><code>TSpinPolicy</code> is a local variable in functions that require spin functionality whereas <code>TChannelPolicy</code> is a field in <code>SharedChannel</code> class.</p>
<p>We do not share <code>TSpinPolicy</code> across multiple writers, so each thread creates its own object.
The <code>SharedChannel</code> contains a single instance <code>TChannelPolicy</code> which contains a synchronization primitive used to signal remote process when there is a new frame.</p>
<h3 id="notes">Notes</h3>
<p>The implementation of shared channel is heavily influenced by C# metaprograming:<br>
<a href="https://www.youtube.com/watch?v=UybGH0xL5ns">Federico Lois — Metaprogramming for the masses</a></p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>

 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#contents">Contents</a></li>
    <li><a href="#shared-channel">Shared Channel</a>
      <ul>
        <li><a href="#principles">Principles</a></li>
        <li><a href="#circular-buffer-algorithm">Circular buffer algorithm</a></li>
        <li><a href="#scaling-out-readers">Scaling out readers</a></li>
      </ul>
    </li>
    <li><a href="#shared-channel-implementation">Shared channel implementation</a>
      <ul>
        <li><a href="#diagram">Diagram</a></li>
        <li><a href="#policies">Policies</a></li>
        <li><a href="#notes">Notes</a></li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












